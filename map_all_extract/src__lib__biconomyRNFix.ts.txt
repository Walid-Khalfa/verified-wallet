import {
  createPublicClient,
  encodeAbiParameters,
  encodeFunctionData,
  pad,
  toHex,
  zeroAddress,
  zeroHash,
} from "viem";
import BOOSTRAP from "./abi/boostrap.json";
import FACTORY from "./abi/factory.json";

const NEXUS_ACCOUNT_FACTORY_ADDRESS =
  "0x000000001D1D5004a02bAfAb9de2D6CE5b7B13de";
const NEXUS_BOOTSTRAP_ADDRESS = "0x00000000D3254452a909E4eeD47455Af7E27C289";
const DUMMY_SIGNATURE =
  "0x81d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b";
const index = 0n;

const toInitData = (mod: any) => {
  const module = mod.module || mod.address;
  const data = mod.initData || mod.data;
  if (!module || !data) {
    throw new Error("Module or data is missing");
  }
  return { module, data };
};

const getInitData = (params: any) =>
  encodeAbiParameters(
    [
      { name: "bootstrap", type: "address" },
      { name: "initData", type: "bytes" },
    ],
    [
      params.bootStrapAddress,
      encodeFunctionData({
        abi: BOOSTRAP.abi,
        functionName: "initNexusWithDefaultValidatorAndOtherModulesNoRegistry",
        args: [
          params.defaultValidator.data,
          params.validators,
          params.executors,
          params.hook,
          params.fallbacks,
          params.prevalidationHooks,
        ],
      }),
    ]
  );

const toValidator = (parameters: any) => {
  const {
    deInitData = "0x",
    type = "validator",
    signer,
    data = "0x",
    module,
    ...rest
  } = parameters;
  return {
    deInitData,
    data,
    module,
    address: module,
    signer,
    type,
    getStubSignature: async () => DUMMY_SIGNATURE,
    signUserOpHash: async (userOpHash: any) =>
      await signer.signMessage({ message: { raw: userOpHash } }),
    signMessage: async (message: any) => await signer.signMessage({ message }),
    ...rest,
  };
};

const toDefaultModule = (parameters: any) =>
  toValidator({
    initData: parameters.signer.address,
    data: parameters.signer.address,
    deInitData: "0x",
    ...parameters,
    address: zeroAddress,
    module: zeroAddress,
    type: "validator",
    getStubSignature: async () => DUMMY_SIGNATURE,
  });

const toEmptyHook = () => ({
  module: zeroAddress,
  data: zeroHash,
});

export const computeNexusAccount = async (
  chain: any,
  transport: any,
  signer: any
) => {
  const publicClient = createPublicClient({ chain, transport });

  const defaultValidator = toDefaultModule({ signer });
  const validators = [];
  const executors = [];
  const hook = toEmptyHook();
  const fallbacks = [];
  const registryAddress = zeroAddress;
  const factoryAddress = NEXUS_ACCOUNT_FACTORY_ADDRESS;
  const bootStrapAddress = NEXUS_BOOTSTRAP_ADDRESS;
  const prevalidationHooks = [];

  const initData = getInitData({
    defaultValidator: toInitData(defaultValidator),
    validators: validators.map(toInitData),
    executors: executors.map(toInitData),
    hook: toInitData(hook),
    fallbacks: fallbacks.map(toInitData),
    registryAddress,
    bootStrapAddress,
    prevalidationHooks,
  });

  const salt = pad(toHex(index), { size: 32 });
  const nexusAccount: any = await publicClient.readContract({
    address: factoryAddress,
    abi: FACTORY.abi,
    functionName: "computeAccountAddress",
    args: [initData, salt],
    authorizationList: undefined,
  });
  if (nexusAccount?.toLowerCase() !== zeroAddress?.toLowerCase()) {
    return nexusAccount;
  }
  return;
};
